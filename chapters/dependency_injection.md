# Внедрение зависимости (Dependency Injection) {#di}


Постепенно наши программы растут и некоторые части приложения должны общаться с другими модулями. Когда модулю `A` необходим модуль `B` для запуска, мы говорим что `B` - это _зависимость_ от `A`.

Самый распространненный способ, чтобы получить доступ к зависимостям это просто сделать `import` файла. Например: у нас есть модуль, в котором мы можем делать следующее:

```js
// в A.ts
import {B} from 'B'; // зависимость!

B.foo(); // использует B
```

В большинстве случаев просто импортирование файла вполне достаточно, но иногда мы должны предоставлять зависимости в более изысканым способом. Например, нам может понадобится:

* подмена реализации `B` для тестов
* использование только одного экземляра `B` по всему приложению (т.е. паттерн _Singleton_ )
* создатвать новый экземпляр класса `B`, когда он используется (т.е. паттерн _Factory_)

Внедрение зависимости может решить эти задачи.

Dependency Injection (DI) - это система, которая делает части программы доступными для других частей и мы можем настроить то, как это будет происходить.

T> Мы можем думать о "инжекторе", как заменителе оператора `new`. То есть, вместо предложенного синтаксисом языка оператора `new`, Dependency Injection позволяет задать то как будет создан объект.

Термин Dependency Injection используется, чтобы описать дизайн паттерн(используемый в других фреймворках), также конкретную его реализацию встроенную в Angular.

Основное преимущество использования Dependency Injection в том, что пользователь **не дожен беспокоиться о создании зависимостей**. Единственное что пользователь должен знать - это как взаимодействовать с этими зависимостями. Это довольно абстрактно, поэтому давайте перейдем к коду.

T> **Как использовать эту главу**
T>
T> Эта глава - экскурс в Angular DI механизм и концепты. Вы можете найти код этой главы в `code/dependency-injection`.
T>
T> Во время чтения главы, перейдите в директорию демо проекта и запустите его командами:
T>
T>     npm install
T>     npm start
T>
T> As a preview, to get Dependency Injection to work involves configuration in your `NgModules`. It can feel a bit confusing at first to figure out "where" things are coming from.
T>
T> Пример кода содержит полноценный рабочий пример со всем содержимым. Так что, если вы не хотите в нем потерятся, то мы рекомендуем вам смотреть код параллельно с чтением этой главы.

## Пример внеднеия: `PriceService`

Давайте представим что мы делаем магазин, которые имеет продукты (`Product`) и нам нужно посчитать итоговую стоимость с учетом налогов. Чтобы посчитать полную стоимость для продукта, мы используем `PriceService`, который принимает на вход:

* базовую цену продукта
* штат, где мы продаем продукт

и возвращаем конечную стоимость продукта с налогами:

{lang=js}
<<[code/dependency-injection/src/app/price-service-demo/price.service.1.ts](code/dependency-injection/src/app/price-service-demo/price.service.1.ts)

В этом сервисе функция `calculateTotalPrice` принимает `basePrice` продукта и  `state` и возвращает итоговую цену продукта.

Предположим, что мы захотим использовать этот сервис в модели `Product`. Вот как это могло бы выглядеть без внедрения зависимости:

{lang=js}
<<[code/dependency-injection/src/app/price-service-demo/product.model.1.ts](code/dependency-injection/src/app/price-service-demo/product.model.1.ts)

Теперь представим, что нам нужно написать тест для класса `Product`. Мы можем наеписать где-то такой тест:

```
import { Product } from './product';

describe('Product', () => {

  let product;

  beforeEach(() => {
    product = new Product(11);
  });

  describe('price', () => {
    it('is calculated based on the basePrice and the state', () => {
      expect(product.totalPrice('FL')).toBe(11.66); // <-- hmmm
    });
  })

});
```
Проблема с этим тестом том, что мы не знаем какой будет налог во Флориде(`'FL'`). И даже если мы реализуем `PriceService`, который будет делать запрос к API c обращением к базе данных, у нас возникнут другие сложности:

* API должно быть доступно (база запущена) и
* Мы должны знать значение налога в конкретный момент времени запуска теста.

Но что нам делать, если мы хотим протестировать метод `price` без надежды на внешний ресуорс? В этом случае мы часто _мокаем_ `PriceService`. Например: если мы знаем интерфейс `PriceService`, то мы можем создать `MockPriceService`, который всегда нам возвращает предсказуемые значения (и не зависит от API или базы данных).

Вот интерфейс `IPriceService`:

{lang=js}
<<[code/dependency-injection/src/app/price-service-demo/price-service.interface.ts](code/dependency-injection/src/app/price-service-demo/price-service.interface.ts)

Интерфейс определяет всего одну функцию: `calculateTotalPrice`. Теперь мы можем создать `MockPriceService` который соотвествует интерфейусу и который будем использовать только для тестов:

{lang=js}
<<[code/dependency-injection/src/app/price-service-demo/price.service.mock.ts](code/dependency-injection/src/app/price-service-demo/price.service.mock.ts)

Теперь, только потому что мы создали `MockPriceService` это еще не значит что наш `Product` будет его использовать. Чтобы использовать этот сервис, мы должны изменить класс `Product`:

{lang=js}
<<[code/dependency-injection/src/app/price-service-demo/product.model.ts](code/dependency-injection/src/app/price-service-demo/product.model.ts)

Теперь, при создании продукта **пользователь класса `Product` становится отвественный за то какая из реализации `PriceService` будет использована в создании экземляра**.

Этим изменением мы можем немного улучшить наш тест и избавиться от зависимости на непредстказуемый `PriceService`:

{lang=js}
<<[code/dependency-injection/src/app/price-service-demo/product.spec.ts](code/dependency-injection/src/app/price-service-demo/product.spec.ts)

Мы также получаем бонус - уверенность в том что мы тестируем класс `Product` _изолированно_. То есть мы гарантируем, что наш класс работает с предсказуемыми зависимостями.

Предсказуемость - это хорошо, но получается довольно трудоемко каждый раз передавать конкртную реализацию сервиса, когда мы хотим получить новый продукт. К счастью, Angular уже имеет встроенный механизм, который помагает нам решить эту задачу.

Используая Angular мы не будем просто импортировать зависимость, а потом создавать новоую сущность, а:

* Регистрировать "зависимость" в Angular
* Описывать _как_ зависимость должна быть _внедрена_
Describe _how_ the dependency will be _injected_
* Внедряем зависимость

Одно из преимуществ такой модели, что реализация зависимости может быть подменена в процессе выполнения (как в примере выше). Другой серьзный плюс это то, что мы можем настраивать *как будет создана зависимость*.

Довольно распространенный случай использования сервисов - **один экземпляр** - синглтон. Механизм внедрения зависимостей позволяет просто настроить получение синглтона.

Третий случай использования DI - настройка переменных окружения. Например: мы могли бы задать "константу" `API_URL`, а потом инжектировать различные зачения для продакшен среды и для среды разработки.

Давайте разберем как создавать свои сервисы и различных способы их внедрения.

## Составные части Механизма Внедрения Зависимостей

Чтобы зарегистрировать зависимосто мы должны привязать ее к чему-то, что будет **индентифицировать эту зависимость**. Идентификация называется **токеном** зависимости. Например, если мы хотим зарегистрировать значение URL API, мы можем использовать строку `API_URL`, как токен. Таким же образом, если мы регистрируем класс, то мы можем использовать сам класс как **токен**.

Мы можем выделить 3 основные состовляющие механизма:

- **Provider** задает _токен_ (который может быть классом либо строкой) для зависимостей. и говорит Angular как должна быть создана зависимость по конкретному токену.
- **Injector** который хранит набор связей и отвечает за разрешение зависимостей при создании объекта
- **Dependency** - то что инжектируется

Взаимодействие элементов механизма проиллюстрировано на диаграме:

![Dependency Injection](images/dependency-injection/dependency-injection-diagram.png)

Мы можем думать об этом как задание того **что** должно инжектироваться и **как** будет создан объект для этой зависимости.

## Эксперименты с Инжетором

Выше мы вручную создали `PriceService` используя оператор `new`. Это дублирует то, что уже делает Angular.

Angular использует _инжектор_, чтобы **разрешить** зависимость и **создать объект**. Это происходит за кулисами, но для практики хорошо будет исследовать что происхдоит. Может быть полезно использовать инжектор вручную, чтобы посмотреть что делает Angular за кулисами.

Давайте **используем инжектор напрямую** в нашем компоненте, чтобы создать сервис. (После того как мы проделаем это вручную, мы покажем способ как это сделат проще используя встроенные возможности.)

Один из основных вариантов использования сервисов - глобальный объект синглтон. Например: у нас может быть `UserService`, который содержит информацию о текущем залогиненом пользователе. Множество компонентов может строить свою логику оталкиваясь от предоставленной информации, поэтому это хороший пример для сервиса.

Вот базовый сервис `UserService`, который хранит объект пользователя как свойство:

{lang=js}
<<[code/dependency-injection/src/app/services/user.service.ts](code/dependency-injection/src/app/services/user.service.ts)

Скажем, мы захотели сделать игрушечную форму авторизации:

{lang=html}
<<[code/dependency-injection/src/app/user-demo/user-demo.component.html](code/dependency-injection/src/app/user-demo/user-demo.component.html)

Выше мы кликаем на кнопку "Sign In", чтобы вызвать функцию `signIn()` (которую мы скоро определим). Если у нас есть имя пользователя (`userName`), то мы выведем привествие.

![Simple Sign In Button](images/dependency-injection/di-sign-in-button.png)

Теперь давайте реализуем эту функциональность в нашем компоненте обращаясь к **инжектору напрямую**.

{lang=js}
<<[code/dependency-injection/src/app/user-demo/user-demo.injector.component.ts](code/dependency-injection/src/app/user-demo/user-demo.injector.component.ts)

Все начинается также как в базовом компоненте: у нас есть селектор, шаблон и стили. Учтите, что у нас сейчас 2 свойства: `userName`, которое хранит имя залогиненого пользователя и `userService`, которое содержит ссылку на `UserService`.

Конструкторе нашего компонента мы используем статический метод `resolveAndCreate` класса `ReflectiveInjector`. Этот метод отвественный за создание нового инжектора. Как параметр мы передаем массив со всеми нашими **инжектируемыми сущностями**, которые хотим чтобы вошли в инжектор. В нашем случае мы только хотим указать `UserService`.

T> `ReflectiveInjector` - это реализация инжектора, котоаря использует _рефлексию_, чтобы определить необходимые типы параметров. В то время как существуют и другие инжекторы,  `ReflectiveInjector` является стандартным инжектором, который мы используем в большинстве приложений.

![Signed In](images/dependency-injection/di-signed-in-button.png)

## Определяем зависимости на уровне `NgModule`

Да, интересно посмотреть как создать инжектор напрямую, но это не то как мы его используем в большей части случаев. Обычно мы делаем следующее:

* используем `NgModule` чтобы задать *как мы инжектируем* -- такое описание называется _провайдером_
* используем декораторы (обычно на конструкторе), чтобы задать **что мы инжектируем**

Используя это описание **Angular** может создать инжектор и разрешить зависимости.

Давайте сконвертируем наш `UserService` в инжектируемую сущность, которая будте являтся синглтоном для всего приложения. Во-первых, мы должны добавить его в `providers` свойство `NgModule`:

{lang=js}
<<[code/dependency-injection/src/app/user-demo/user-demo.module.ts](code/dependency-injection/src/app/user-demo/user-demo.module.ts)

Теперь мы можем инжектировать `UserService` в наш компонент вот так:

{lang=js}
<<[code/dependency-injection/src/app/user-demo/user-demo.component.ts](code/dependency-injection/src/app/user-demo/user-demo.component.ts)

Обратите внимание что мы сделали `userService: UserService` аргументов контрутора нашего компонента `UserDemoComponent`. Теперь при создании компонента **Angular разрешит и внедрит синглтон `UserService`**. Прелесть в том, что, так как Angular сам разрешает все зависимости, и нам не нужно беспокоиться: при инжектировании `UserService`  в другой компонент это будет тот же синглтон.

### Providers are the Key

Важно понимать, что когда вы задаете `UserService` как параметр конструктора `UserDemoComponent`, Angular будет знать что инжектировать (и как), потому что мы указали `UserService` как ключ в провайдерах `NgModule`.

Он не инжектирует произвольные классы. Вам **нужно** настроить `NgModule`, чтобы это работало.

Мы много говорили о Синглтон-сервисах, но мы можем инжектировать сущности другими способами. Давайте разберем.

## Провайдеры

Существует несколько способов настройки создания инжектируемой сущности в Angular. Например, мы можем:

* Инжектировать (синглтон) экземпляр класса (как уже было разобрано)
* Инжектировать **значение**
* **Вызывать любую функцию** и инжектировать значение, которое она возвращает

Давайте посмотрим детально как мы можем создать каждый:

### Используя класс

Как мы уже обсуждали, инжектирование синглтон экземпляра класса это вероятно самый распространенный случай.

Мы можем задать сам класс в список провайдеров:

```javascript
  providers: [ UserService ]
```

Этим мы скажем Angular, что мы хотим предоставить нашу зависимость как синглтон экземпляр класса `UserService`. Так как это самый распространненый случай, мы можем использовать короткую форму записи, эквивалентом которой является:

```javascript
   providers: [
     { provide: UserService, useClass: UserService }
   ]
```

Отметим также что для определения провайдера нам нужно **2 ключа**: `provide` - токен, который мы используем, чтобы однозначно идентифицировать инжектируемую сущности, и второй - `useClass` - указывает на то что и как мы будем инжектировать.

В данном случае мы определяем _класс_ `UserService` по _токену_ `UserService`, то есть 2 ключа совпадают. Это довольно распространенный случай, однако ключ и инжектируемая сущность не обязательно должны иметь одно и тоже _имя_.

Примере приведеном выше инжектор создаст **синглтон** и будет всегда возвращать одну и туже сущность при каждом инжектировании. Конечно, при первом инжектировании сущность еще не создана, поэтому первом инжектировании `UserService`.

#### Использованмие значения

Другой способ использования DI - предоставить значение, что-то вроде глобальной костанты. Нарпимер: мы можем настоить URL нашего API по разному в зависимости от среды.

Чтобы сделать это, при определении провайдера в`NgModule` мы используем клюс `useValue`:

```javascript
  providers: [
    { provide: 'API_URL', useValue: 'http://my.api.com/v1' }
  ]
```

- чтобы задать токен мы используем *строковое значение* `API_URL`. Теперь, чтобы инжектировать сущность определенную данным провайдером, мы **не можем** просто написать:

```javascript
// doesn't work - anti-example
export class AnalyticsDemoComponent {
  constructor(apiUrl: 'API_URL') { // <--- this isn't a type, just a string
                                   // if we put `string` that is ambiguous
  }
}
```

Так как же нам быть? В этом случае мы используем декоратор `@Inject()`:

```javascript
import { Inject } from '@angular/core';

export class AnalyticsDemoComponent {
  constructor(@Inject('API_URL') apiUrl: string) {
   // works! do something w/ apiUrl
  }
}
```
<!--
TODO - discuss InjectableToken in ng4
-->

Мы разоборали как инжектировать простые значения(`useValue`) и синглтон сущности (`useClass`), и готовы поговорить о более серьзных вещах: создание настраиваемых сервисов с помощью фабрики.

#### Настраеваемые сервисы

В случае с `UserService`, конструктор класса не требует доволнительных параметров. Но что если параметры необходимы? Мы можем решить это используя _фабрику_ - функцию, которая вернет **любой объект** в случае инжекта.

Например: мы создаем библиотеку для записи пользовательской аналитики (записываем все действия, которые пользователь делает на странице). В данном
For instance, let's say we're writing a library for recording user analytics (that is, keeping a record of events of actions a user took on the page). In this scenario, we want to have an `AnalyticsService` with a catch: the `AnalyticsService` should define the interface for _recording_ events, **but not the implementation for handling the event**.

![Tracking Analytics on the events](images/dependency-injection/di-pet-store.png)

Наш пользователь может захотеть записать эти метрики с помощью Google Analytics или использовать Optimizely или какое-то свое решение. Давайте создадим сервис `AnalyticsService` так, чтобы он смог принимать настройки.

Но сначала введем определение `Metric`:

{lang=js,crop-query=.Metric}
<<[code/dependency-injection/src/app/analytics-demo/analytics-demo.interface.ts](code/dependency-injection/src/app/analytics-demo/analytics-demo.interface.ts)

`Metric` будет созранять `eventName` в `scope`, то есть когда пользователь `nate` проходит логин (назовем событие `loggedIn`), то в метрике мы запишем:

```javascript
// just an example
let metric: Metric = {
  eventName: 'loggedIn',
  scope: 'nate'
}
```

Данном случае, в теории, мы можем посчитать сколько раз пользователи логинились, а также количество раз для конкретного пользоваля.

Мы также должны определить что будет из себя представлять сама реализация аналитики:

{lang=js,crop-query=.AnalyticsImplementation}
<<[code/dependency-injection/src/app/analytics-demo/analytics-demo.interface.ts](code/dependency-injection/src/app/analytics-demo/analytics-demo.interface.ts)

Мы создаем интерфейс `AnalyticsImplementation`, который определяет одну функцию `recordEvent`, принимающую `Metric` как аргумент.

Теперь давайте определим `AnalyticsService`, и в нем метод `record`:

{lang=js}
<<[code/dependency-injection/src/app/services/analytics.service.ts](code/dependency-injection/src/app/services/analytics.service.ts)

Обратили внимание что констркутор класса принимает фразу как параметр? Если мы попробуем использовать привычный "useClass" способ, то получим следующую ошибку:

```text
Cannot resolve all parameters for AnalyticsService.
```

Это произошло, потому что мы не предоставили инжектору достаточно информации для констркуотра. Чтобы решить эту задачу, нам нужно сконфигурировать провайдер, чтобы сущность создавалась **используя фабрику**.

### Использование фабрики

Итак, чтобы использовать наш `AnalyticsService`, нам нужно:

* реализовать интерфейс `AnalyticsImplementation`
* добавить класс в `providers` с `useFactory`

Вот как:

{lang=js}
<<[code/dependency-injection/src/app/analytics-demo/analytics-demo.module.1.ts](code/dependency-injection/src/app/analytics-demo/analytics-demo.module.1.ts)

В провайдерах мы используем следующий синтаксис:

```javascript
providers: [
  { provide: AnalyticsService, useFactory: () => ... }
]
```

Клюсем `useFactory` мы задаем провайдеру инжектировать **люое значение возвращаемое функцией**.

Также отметим, что в `provide` мы по прежнему задаем `AnalyticsService` как _токен_ для инжектирования (Вы бы могли использовать другой класс или даже строку).

В `useFactory` мы создаем объект по интерфейсу `AnalyticsImplementation`, которые имеет метод `recordEvent`. По сути `recordEvent` - это то место, где мы задаем **что** происходит, когда записывается событие. Еще раз: в реальном приложении мы бы наверное отправляли событие в Google Analytics или другую службу логирования.

И в конечном итоге, мы инициируем наш `AnalyticsService` и возвращаем его.

#### Зависимости фабрики

Использование фабрики - это очень мощный способ создавать инжектируемые сущности, потому что мы можем делать что захотим внутри фабричной функции. Иногда фабрика сама требует каких-то зависимостей.

Скажем, что мы хотим настроить наш `AnalyticsImplementation` так, чтобы отправлять HTTP запрос на конкретный URL. Чтобы сделать это нам нужно:

* Angular `Http` и
* наше значение `API_URL`

Вот как мы можем это задать:

{lang=js}
<<[code/dependency-injection/src/app/analytics-demo/analytics-demo.module.ts](code/dependency-injection/src/app/analytics-demo/analytics-demo.module.ts)

- мы импортировали `HttpModule` и прописали в `NgModule`, что делает доступными сущности модуля для инжектирования.

Мы добавили провайдер для `API_URL`, как было описано выше. И далее в провайдере для `AnalyticsService` мы добавляем новый ключ-свойство `deps`. `deps` является массивом инжектируемых токенов, которые будут разрешены и инжектируемые сущности **добавлены в фабричную функцию как параметры**.

## Dependency Injection in Apps

Когда вы создаете ваши приложения вам нужно сделать 3 действия, чтобы добавить инжектируемую сущность:

1. Создать саму зависимость (т.е. класс сервис)
2. Настроить провайдер для инжектируемой сущности в `NgModule`
3. Определить зависимости в конструкторе

Первое - это создать класс сервис, то есть, класс, которые предоставляет необходимую нам функциональность.
The first thing we do is create the service class, that is, the class that exposes some behavior we want to use. This will be called the *injectable* because it is the *thing* that our components will receive via the _injection_.

Напоминаем терминологию: _провайдер_ предоставляет(создает, инициирует...) _инжектируемую сущность_. В Angular, когда вы хотите получить _инжектируемую сущность_ вы _инжектируете_ зависимость в функцию (часто конструктор) и Angular
Reminder on terminology: a _provider_ provides (creates, instantiates, etc.) the _injectable_ (the thing  you want). In Angular when you want to access an _injectable_ you _inject_ a dependency into a function (often a `constructor`) and Angular's dependency injection framework will locate it and provide it to you.

Как мы видим, внедрение зависимостей предоставляет мощный способ управления зависимостями в вашем приложении.

## Дополнительные ресурсы

* [Официльная документация Angular](https://angular.io/docs/ts/latest/guide/dependency-injection.html)
* [Victor Savkin Compare DI in Angular 1 vs. Angular 2](http://victorsavkin.com/post/126514197956/dependency-injection-in-angular-1-and-angular-2)
