# Роутинг {#routing}

В вэб-разработке, _роутинг_ (или _маршрутизация_) - означает разделение приложения на части на основании правил, полученных из текущего адреса в браузере (URL).

Например, если мы введём `/` в адресной строке браузера, то окажемся на стартовой странице сайта. А если введём `/about` - отобразится страница "about", и так далее.

## Зачемм нужен Роутинг?

Определяя роуты мы можем:

- отделить друг от друга разные области приложения;
- поддерживать состояние приложения;
- ограничить доступ к некоторым областям на основе определённых правил;

Представьте, что мы пишем приложение учёта, как в предыдущих главах.

Когда мы впервые посетим приложение, мы увидим форму поиска, куда можно ввести поисковый запрос и получить список продуктов, соответствующих этому запросу.

После этого мы можем кликнуть на товаре, чтобы открыть страницу с его деталями.

Поскольку мы разрабатываем клиентское (браузерное) приложение, технически мы могли бы вообще не менять URL при смене страниц. Но использование одного и того же адреса для всех страниц имеет ряд существенных недостатков:

- невозможно перезагрузить страницу оставшись на том же месте
- невозможно сделать закладку чтобы вернуться в то же место позже
- нельзя поделиться ссылкой с другими

Роутинг позволяет нам задать набор роутов для каждого действия:

Когда пользователь заходит по базовому адресу нашего приложения `http://our-app/`, мы можем перенаправить его на домашнюю страницу по адресу `http://our-app/home`.

Для доступа к странице 'About Us' можно использовать адрес `http://our-app/about`. Если другой пользователь зайдёт по этой же ссылке он увидит ту же страницу.

## Как работает клиентский _Роутинг_

Допустим у нас есть серверное приложение. Для каждого HTTP-запроса серверный _роутинг_ будет по URL-адресу определять нужный контроллер и возвращать HTML страницу отрисованную этим контроллером.

Например на [Express.js](http://expressjs.com/guide/routing.html) можно на писать такой код:

```javascript
var express = require('express');
var router = express.Router();

// define the about route
router.get('/about', function(req, res) {
  res.send('About us');
});
```

Или на [Ruby on Rails](http://rubyonrails.org/) это могло бы выглядеть так:

```ruby
# routes.rb
get '/about', to: 'pages#about'

# PagesController.rb
class PagesController < ActionController::Base
  def about
    render
  end
end
```

В обоих случаях у нас есть **сервер**, который принимает запрос и напрявляет на **контроллер**, который выолняет определённое **действие** в зависимости от адреса и параметров.

Клиентский _роутинг_ строится по такому же принципу. Основное отличие в том, что **мы не обязаны делать запрос к серверу** при каждой смене адреса. Angular-приложения называются _одностраничными_ (SPA) ("Single Page Apps"), потому что сервер возвращает только одну страницу, а Javascript на ней уже геерирует все остальные.

Так как же мы можем создать различные _роуты_ в нашем JavaScript коде?

### Начало: использование якорей

Клиентский _роутинг_ начинается с ловкого трюка: вместо того, чтобы использовать нормальный серверный URL-адрес для страниц нашего SPA, мы используем якорь как клиентский адрес.

Как вы уже наверное знаете, обычно якоря использовались для того чтобы указать на конкретное место сраницы и прокрутить до него. Например если задать якорь на HTML-странице:

```html
<!-- ... lots of page content here ... -->
<a name="about"><h1>About</h1></a>
```

И перейти по адресу `http://something/#about`, браузер прыгнет прямо к тэгу H1, который помечен якорем `about`.

Разумным шагом клиентских фрэймворков для представления _роутов_ в приложении было использование якорей, сформатированных как пути.

Например, _роут_ `about` выглядел бы так `http://something/#/about`. Это называют **hash-based routing**.

Изящество этого решения в том что это адрес выглядит как "нормальный", поскольку якорь начинается со слэша (`/about`).

### Эволюция": HTML5 клиентский _роутинг_

С появлением HTML5 появилась возможность программно создавать новые записи в истории браузера, тем самым меняя URL-адрес _без необходимость отправлять новый запрос на сервер_.

Это достигается за счёт использования метода `history.pushState` который даёт возможность управлять историей навигации из JavaScript.

Поэтому современные фрэймворки могут использовать `pushState` вместо якорей для управление историей без перезагрузки страницы.

T> **Angular 1 примечание**: Такой роутинг работает и в Angular 1, но эту возможность нужно активировать явно используя `$locationProvider.html5Mode(true)`.

В Angular, HTML5 навигация включена по умолчанию. Дальше в этой главе мы покажем как активировать старый режим с использованием якорей.

W> Есть два момента, которые необходимо помнить о HTML5 роуинге:
W>
W> 1. Не все браузеры поддерживают HTML5 роутинг, так что если вам необходимо поддерживать старые браузеры, придётся использовать якоря.
W> 2. **Сервер не поддерживает HTML5 роутинг**.
W>
W> Второе утрверждение не так очевидно, дальше в этой главе мы обсудим почему.

## Создание первого роута Writing our first routes

W> Документация Angular [рекомендует использовать HTML5 роутинг](https://angular.io/docs/ts/latest/guide/router.html#!#browser-url-styles). Но учитывая сложности, описанные в предыдущей главе, мы будем использовать якоря в наших примерах.

В Angular мы настраиваем роуты ставя в соответствие _пути_ и компоненты, которые будут срабатывать по каждому из них.

Давайте создадим небольшое приложение с 3 роутами:

- Путь `/#/home` будет соответствовать главной странице;
- `/#/about` - странице "about";
- `/#/contact` - странице контактов;

Когда пользователь заходит на базовый URL (`/#/`), он будет перенаправлен на домашнюю страницу.

## Из чего состоит роутинг Angular

Есть три основных элемента, которые мы используем, чтобы настрить роутинг в Angular:

- `Routes` описывает, какие роуты поддерживает наше приложение
- `RouterOutlet` говорит Angular, куда вывести содержимое для каждого роута
- `RouterLink` директива используется, чтобы создавать ссылки соответствующие роутам

Давайте рассмотрим внимательнее каждый из них.

### Импорты

Чтобы использовать роутер в Angular, мы импортируем константы из пакета `@angular/router`:

{lang=javascript,crop-query='@angular/router'}
<<[code/routes/routing/src/app/app.module.ts](code/routes/routing/src/app/app.module.ts)

Теперь мы можем определить конфигурацию для нашего роутера.













## Заключение

Новый роутер Angular очень мощный и гибкий. Остаётся только добавить его в ваши приложения!