# Формы в Angular {#forms}

## Такие важные и сложные формы

Вероятнее всего, формы являются наиболее важной частью веб-приложения. Несмотря на 

Несмотря на обилие нажатий по ссылкам и перемещений курсора, все же самую большую и важную часть данных от пользователей мы получаем через _формы_.

На первый взгляд, формы кажутся очень простыми: вы создаете тэг `input`, пользователь заполняет форму и нажимает submit. Неужели все так сложно?

Оказывается, формы могут быть очень сложными. И вот почему:

* Формы могут использоваться для изменения данных как на странице, так и на сервере
* Очень часто изменения должны быть отображены в другой части страницы
* Пользователи не ограничены в том, что они ввводят. Следовательно, у нас должна быть возможность проверять эти данные
* Пользовательский интерфейс должен: быть предсказуемым и четко обрабатывать ошибки, в случае их появления
* Зависимые поля могут иметь сложную логику
* У нас должна быть возможность тестировать наши формы, не прибегая к DOM селекторам

К счастью, в Angular есть инструменты, которые помогут нам решить эти проблемы.

* **`FormControl`** позволяет нам инкапсулировать данные формы и предоставляет объекты для работы с ними
* **`Validator`** позволяет нам проверять данные любым способом, которым мы захотим
* **Observers** позволяет нам отслеживать изменения в формах и реагировать на них соответствующим образом

В этой главе, шаг за шагом, мы рассмотрим, как создаются формы. Мы начнем с простых формы и дальше будем усложнять их логику.

## `FormControl` и `FormGroup`

Два основных объекта в Angular формах - это `FormControl` и `FormGroup`.

### `FormControl`

`FormControl` представляет собой одно поле ввода - это наименьшая часть формы в Angular.

`FormControl` инкапсулирует данные формы и состояния, сообщающие о валидности, изменениях или начилии ошибок.

Например, вот так мы можем использовать `FormControl` в TypeScript:

```javascript
// создаем новый FormControl со значением "Nate"
let nameControl = new FormControl("Nate");

let name = nameControl.value; // -> Nate

// теперь мы можем запросить информацию о состояниях:
nameControl.errors // -> StringMap<string, any> of errors
nameControl.dirty  // -> false
nameControl.valid  // -> true
// и т.д.
```

Для создания формы мы создаем `FormControl`ы (или группу `FormControl`), а затем присоединяем к ним метаданные и логику.

Как и многое другое в Angular, мы добавляем класс (в данном случае `FormControl`) в DOM с помощью атрибута (в данном случае `formControl`). В итоге, это может выглядеть так:

```html
<!-- часть большой формы -->
<input type="text" [formControl]="name" />
```

Это создаст новый объект `FormControl` в контексте нашей формы. Далее мы подробно разберем, как это работает.

### `FormGroup`

Многие формы состоят из нескольких полей, поэтому нам нужен способ управления несколькими `FormControl`. Если мы хотим проверить правильность нашей формы, то перебор в массиве всех `FormControl` с валидацией каждого элемента будет выглядеть достаточно громоздким. `FormGroup` решает эту проблему путем создания интерфейса обертки вокруг коллекции `FormControl`.

Создадим `FormGroup`:

```javascript
let personInfo = new FormGroup({
    firstName: new FormControl("Nate"),
    lastName: new FormControl("Murray"),
    zip: new FormControl("90210")
})
```

`У FormGroup` и `FormControl` общий предок ([`AbstractControl`](https://angular.io/docs/ts/latest/api/forms/index/AbstractControl-class.html)). Это означает, что мы можем проверить `status` или `value` у `personInfo` так же легко. как и у одного `FormControl`:

```javascript
personInfo.value; // -> {
//   firstName: "Nate",
//   lastName: "Murray",
//   zip: "90210"
// }

// теперь мы можем запросить информацию о состоянии группы,
// значение котороц зависит от значений дочерних 'FormControl':
personInfo.errors // -> StringMap<string, any> of errors
personInfo.dirty  // -> false
personInfo.valid  // -> true
// и т.д.
```

Обратите внимание, когда мы пытаемя получить `value` из `FormGroup` мы получаем **объект** с парами ключ-значение. Очень удобно получать весь список значений нашей формы без перебора всех `FormControl`.

## Наша первая форма

Существует множество ньюансов при создании формы, и некоторые важные их них мы еще не затрагивали. Поэтому, давайте перейдем к примеру и разберем его по частям.

%% BEGIN_BOOK

I> Все примеры кода для данной главы вы можете найти в папке `forms/`

%% END_BOOK

%% BLOG{full_code_listing}

Вот изображение формы, которую мы собираемся создать:

![Пример простой формы Sku](images/forms/demo_form_sku_simple.png)

В нашем воображаемом приложении мы создаем сайт электронной коммерции, на котором мы публикуем продаваемые продукты. В этом приложении нам необходимо сохранять SKU продукта. Поэтому, давайте создадим простую форму, в которой SKU будет единственным полем для ввода данных.

I> SKU - это артикул товара. Это уникальный id продукта, который мы будем отслеживать. В будущем, когда мы говорим о SKU, мы подразумеваем ID продукта.

У нас очень простая форма: всего одно поле ввода для `sku` (с меткой label) и кнопкой submit.

Давайте превратим эту форму в компонент. Если вы помните, для создания компонента необходимо выполнить три шага:

* Сконфигурировать декоратор `@Component()`
* Создать шаблон
* Реализовать пользовательские функции в классе определения компонента

Let's take these in turn:

### Загрузка `FormsModule`

Чтобы начать использовать библиотеку создания форм, нам нужно сначала убедиться в том, что мы ее импортировали в наш `NgModule`.

Существует два способа работы с формами в Angular. В этой главе мы поговорим о каждом из них: с использованием `FormsModule` и `ReactiveFormsModule`. Поскольку мы будем использовать оба варианта, мы импортируем их в наш модуль. Для этого в `app.ts` мы делаем следующее:

{lang=javascript}
    import {
      FormsModule,
      ReactiveFormsModule
    } from '@angular/forms';

    // дальше вниз...

    @NgModule({
      declarations: [
        FormsDemoApp,
        DemoFormSkuComponent,
        // ... наше объявление
      ],
      imports: [
        BrowserModule,
        FormsModule,         // <-- добавили это
        ReactiveFormsModule  // <-- добавили это
      ],
      bootstrap: [ FormsDemoApp ]
    })
    class FormsDemoAppModule {}


Это гарантирует, что мы сможем использовать директивы форм в наших представлениях. Забегая вперед, `FormsModule` дает нам директивы:

- `ngModel` и
- `NgForm`

В то время как `ReactiveFormsModule` дает нам директивы:

- `formControl` и
- `ngFormGroup`

... и еще. Мы не говорили о том, как использовать эти директивы, и что они делают. Но мы скоро это рассмотрим. На данный момент, нам просто нужно запомнить, что импортируя `FormsModule` и `ReactiveFormsModule` в наш `NgModule`, мы можем использовать любую директиву из этого списка в нашем шаблоне или внедрить в наши компоненты.

### Простая форма SKU: декоратор @Component 

Теперь создадим компонент:

{lang=javascript,crop-query=1-.templateUrl}
<<[code/forms/src/app/demo-form-sku/demo-form-sku.component.ts](code/forms/src/app/demo-form-sku/demo-form-sku.component.ts)

Определим `selector`  `app-demo-form-sku`. Если вы помните, `selector` сообщает Angular, что элементы связаны с этим компонентом. В этом случае мы можем использовать этот компонент с помощью тега `app-demo-form-sku`. Например:

{lang="html"}
    <app-demo-form-sku></app-demo-form-sku>

### Простая форма SKU: `template`

Давайте посмотрим на наш шаблон:

{lang=html}
<<[code/forms/src/app/demo-form-sku/demo-form-sku.component.html](code/forms/src/app/demo-form-sku/demo-form-sku.component.html)

#### `form` и `NgForm`

Теперь все стало интереснее: потому что мы импортировали `FormsModule`, который делает для нас доступным `NgForm`. Запомните, всякий раз, когда мы делаем директивы доступными для нашего представления, они **привязываются к любому элементу, который имеет соответствующий `selector`**.

`NgForm` удобен, но **неочевиден**: он вклюачет тэг `form` в его селектор (вместо того, чтобы явным образом добавить `ngForm`, как атрибут). Это означает, что если вы импортируете `FormsModule`, то `NgForm` будет *автоматически* добавлен ко всем формам с тэгом `<form>`, которые есть в вашем представлении. Это действительно удобно, но при этом запутанно, т.к. все происходит неочевидно.

Вот две важные функции, которые нам дает`NgForm`:

1. `FormGroup` названный `ngForm`
2. **`(ngSubmit)`** вывод

Вы можете заметить, что мы используем оба в теге `<form>` в нашем представлении:

{lang=html,crop-start-line=3,crop-end-line=4}
<<[code/forms/src/app/demo-form-sku/demo-form-sku.component.html](code/forms/src/app/demo-form-sku/demo-form-sku.component.html)

Изначально у нас есть `#f="ngForm"`. Синтаксис `#v=thing` говорит, что мы хотим создать локальную переменную для этого представления.

Создаем алиас для `ngForm` относящийся к переменной `#f` для этого представления. Откуда появился `ngForm`? Из директивы `NgForm`.

К какому типу объекта относится `ngForm`? Он относится к `FormGroup`. Значит мы можем использовать `f` как `FormGroup` в нашем представлении. Это как раз то, что мы далем при `(ngSubmit)`.

W> Внимательные читатели могут заметить, что мы говорили, что `NgForm` автоматически привязывается к тэгам `<form>` (из-за селектора `NgForm`). Это означает, что нам не нужно добавлять атрибут `ngForm`, чтобы использовать `NgForm`. Но мы все же помещаем `ngForm` в качестве атрибута тэга. Неужели опечатка?
W>
